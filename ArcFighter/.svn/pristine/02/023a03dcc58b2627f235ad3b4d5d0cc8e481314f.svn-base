program progknifeexamp;
uses
    //wingraph,wincrt
    sysutils,
    osxbgi;
  
const
    appleradius = 20;

type

    TCoord = record
        x,y: real;
        u: real;   
    end;

    TKnifeType = record
        Position: TCoord;
    end;

    TAppleType = record
        Position: TCoord;
       
    end;

var
    Knife: array[0..6] of TKnifeType; // в дальнейшем - массив для ножей, которые будут иметь разные изначальные координаты по у0, х0(?), разный изначальный угол относительно бревна
                        //Куда применить массив ножей(?)
    //KnifeNumber : TKnifeType;
    //CollisionKnife: array[0..6] of TKnifeType;

    AppleSpeed : real; 
    KnifeSpeed : real; 
    KnifeNumber : Integer;
    AppleNumber : Integer;
    AppleCounter, KnifeCounter : integer;

    Apple :array[0..2] of TAppleType;


procedure StartGraphics();
var
    gm,gd: smallInt;
begin
    gd := Nopalette;    
    gm := m800x600;
    InitGraph(gd,gm, 'Knife_HIT');
end;
//Рисование фона
procedure DrawBackGround();
begin
    
    setfillstyle(SolidFill, MidnightBlue);
    bar(0, 0, 800, 100);

    setfillstyle(SolidFill, DarkSlateBlue);
    bar(0, 100, 800, 200);

    setfillstyle(SolidFill, SlateBlue);
    bar(0, 200, 800, 300);

    setfillstyle(SolidFill, MediumSlateBlue);//CeruleanBlue
    bar(0, 300, 800, 400);
    
    setfillstyle(SolidFill, Lilac);//Cerulean
    bar(0, 400, 800, 500);

    setfillstyle(SolidFill, Thistle);//DodgerBlue
    bar(0, 500, 800, 600);
    
    //tfillstyle(SolidFill, lightgreen);
    //r(0,300, 800, 600);
end;
//Рисование бревна, где воткнуты ножи
procedure DrawTree(x, y : Integer);
begin
    SetColor(Sepia);
    setfillstyle(SolidFill, Sepia);
    FillEllipse (x, y, 100,100);

    SetColor(Gold);
    setfillstyle(SolidFill, Gold);
    FillEllipse (x, y, 90,90);

    SetColor(SelectiveYellow);
    setfillstyle(SolidFill, SelectiveYellow);
    FillEllipse (x, y, 70,70);

    SetColor(Gold);
    setfillstyle(SolidFill, Gold);
    FillEllipse (x, y, 50,50);

    SetColor(SelectiveYellow);
    setfillstyle(SolidFill, SelectiveYellow);
    FillEllipse (x, y, 30,30);

    SetColor(Gold);
    setfillstyle(SolidFill, Gold);
    FillEllipse (x, y, 10,10);

end;

procedure DrawOneKnife(y : integer; u:Integer);
var
    //Массив точек для рисования ножа, состоящего из трех элементов:лезвия,ручки,опоры ручки
    polygon: array [0..4] of PointType;
    polygon1: array [0..3] of PointType;
    polygon2: array [0..3] of PointType;
    //Переменные для угла поворота, скорости движения, изначальных координат по х0, у0
    fi: real;
    radius,x :Integer;

begin

    radius:= 100; //удаленность каждой точки массива от начальной точки рисования
   

    x:= 400;
    fi:= 0.05;

    //Массив точек для рисования лезвия 
    polygon[0].x := x + round ((radius  - 20)*cos(fi + (u*pi/180)));
    polygon[0].y := y - round ((radius  - 20)*sin(fi + u*pi/180));

    polygon[1].x := x + round ((radius  - 5)*cos(fi + ((u+5)*pi/180)));
    polygon[1].y := y - round ((radius  - 5)*sin(fi + ((u+5)*pi/180)));

    polygon[2].x := x + round ((radius  + 35)*cos(fi + ((u+3)*pi/180)));
    polygon[2].y := y - round ((radius  + 35)*sin(fi + ((u+3)*pi/180)));

    polygon[3].x := x + round ((radius  + 35)*cos(fi + ((u-5)*pi/180)));
    polygon[3].y := y - round ((radius  + 35)*sin(fi + ((u-5)*pi/180)));

    polygon[4].x := x + round ((radius  - 5)*cos(fi + ((u-5)*pi/180)));
    polygon[4].y := y - round ((radius  - 5)*sin(fi + ((u-5)*pi/180)));

    SetFillStyle(solidFill, LightSkyBlue);
    SetColor(white);
    FillPoly(5, polygon);

    //Массив точек для рисования опоры ручки
    polygon1[0].x := x + round ((radius  + 35)*cos(fi + ((u+5.5)*pi/180)));
    polygon1[0].y := y - round ((radius  + 35)*sin(fi + ((u+5.5)*pi/180)));

    polygon1[1].x := x + round ((radius  + 45)*cos(fi + ((u+5.5)*pi/180)));
    polygon1[1].y := y - round ((radius  + 45)*sin(fi + ((u+5.5)*pi/180)));

    polygon1[2].x := x + round ((radius  + 45)*cos(fi + ((u-6.5)*pi/180)));
    polygon1[2].y := y - round ((radius  + 45)*sin(fi + ((u-6.5)*pi/180)));

    polygon1[3].x := x + round ((radius  + 35)*cos(fi + ((u-6.5)*pi/180)));
    polygon1[3].y := y - round ((radius  + 35)*sin(fi + ((u-6.5)*pi/180)));

    SetFillStyle(solidFill, Burgundy);
    SetColor(Burgundy);
    FillPoly(4, polygon1);

    //Массив точек для рисования ручки ножа
    polygon2[0].x := x + round ((radius  + 45)*cos(fi + ((u+2)*pi/180)));
    polygon2[0].y := y - round ((radius  + 45)*sin(fi + ((u+2)*pi/180)));

    polygon2[1].x := x + round ((radius  + 65)*cos(fi + ((u+2)*pi/180)));
    polygon2[1].y := y - round ((radius  + 65)*sin(fi + ((u+2)*pi/180)));

    polygon2[2].x := x + round ((radius  + 65)*cos(fi + ((u-3.5)*pi/180)));
    polygon2[2].y := y - round ((radius  + 65)*sin(fi + ((u-3.5)*pi/180)));


    polygon2[3].x := x + round ((radius  + 45)*cos(fi + ((u-3.5)*pi/180)));
    polygon2[3].y := y - round ((radius  + 45)*sin(fi + ((u-3.5)*pi/180)));

    SetFillStyle(solidFill, Cinnamon);
    SetColor(Cinnamon);
    FillPoly(4, polygon2); 

   u:= u + 1;

end;

procedure DrawApple(y : integer; u:Integer);
var

    polygon3: array [0..7] of PointType;
    polygon4: array [0..2] of PointType;
    x,x1,y1,radius: Integer;
    fi: real;

begin   

    x := 400;
    radius := 100;

    fi:= 0.05;

    //readkey;

    x1:=  x + round ((radius  + 20)*cos(fi + ((u)*pi/180)));
    y1:= y - round ((radius  + 20)*sin(fi + ((u)*pi/180)));                             


    setfillstyle(SolidFill, Scarlet);
    SetColor(Scarlet);
    FillEllipse(x1, y1, appleradius,appleradius);


    polygon3[0].x := x + round ((radius  + 40)*cos(fi + ((u - 8)*pi/180)));
    polygon3[0].y := y - round ((radius  + 40)*sin(fi + ((u - 8)*pi/180)));  

    polygon3[1].x := x + round ((radius  + 43)*cos(fi + ((u - 6)*pi/180)));
    polygon3[1].y := y - round ((radius  + 43)*sin(fi + ((u - 6)*pi/180)));

    polygon3[2].x := x + round ((radius  + 46)*cos(fi + ((u - 4)*pi/180)));
    polygon3[2].y := y - round ((radius  + 46)*sin(fi + ((u - 4)*pi/180)));

    polygon3[3].x := x + round ((radius  + 43)*cos(fi + ((u - 2)*pi/180)));
    polygon3[3].y := y - round ((radius  + 43)*sin(fi + ((u - 2)*pi/180)));

    polygon3[4].x := x + round ((radius  + 40)*cos(fi + ((u)*pi/180)));
    polygon3[4].y := y - round ((radius  + 40)*sin(fi + ((u)*pi/180)));

    polygon3[5].x := x + round ((radius  + 37)*cos(fi + ((u-2)*pi/180)));
    polygon3[5].y := y - round ((radius  + 37)*sin(fi + ((u-2)*pi/180)));

    polygon3[6].x := x + round ((radius  + 34)*cos(fi + ((u - 4)*pi/180)));
    polygon3[6].y := y - round ((radius  + 34)*sin(fi + ((u - 4)*pi/180)));


    setfillstyle(SolidFill, Green);
    SetColor(Jade);
    FillPoly(7, polygon3); 


    polygon4[0].x := x + round ((radius  + 49)*cos(fi + ((u - 1)*pi/180)));
    polygon4[0].y := y - round ((radius  + 49)*sin(fi + ((u - 1)*pi/180)));  

    polygon4[1].x := x + round ((radius  + 46)*cos(fi + ((u + 0.3)*pi/180)));
    polygon4[1].y := y - round ((radius  + 46)*sin(fi + ((u + 0.3)*pi/180)));

    polygon4[2].x := x + round ((radius  + 40)*cos(fi + ((u )*pi/180)));
    polygon4[2].y := y - round ((radius  + 40)*sin(fi + ((u )*pi/180)));

    setfillstyle(SolidFill, Brown);
    SetColor(Brown);
    FillPoly(3, polygon4); 

    u:= u + 1;

end;






//Функция(процедура?) для коллизии ножа и бревна (что происходит когда нож столкнулся с ножем, что происходит когда нож столкнулся с деревом)
//Функция(процедура?) для коллизии яблока и ножа (что происходит когда нож столкнулся с ножем, что происходит когда нож столкнулся с деревом, что происходит когда нож столкнулся с яблоком)
//Процедуры для разных раундов???

var
    Isquit: boolean;
    vseOK : Boolean;
    
//Процедура реакции на нажатие клавиш (q-выход, w-движение нижнего ножа вверх, чтоб воткнуться в бревно )
procedure Keyboard();//Не работает(?)
var
    button: char; 
    i: integer;
    n: integer;
    
begin

    Isquit := false;


    n := 0;
    i:= 0;
    

    if (keypressed()) then
    begin
        button := readkey();

        if (button = 'q') then
        begin
    
            Isquit := true;
            //exit;
        end;


        if  (button = 'w') and
            (KnifeNumber < 7 )  then
        begin

        for i := 0 to 2 do
        begin
            if  (apple[i].position.u  >= 260) and 
            (apple[i].position.u  <= 280)  and 
            (apple[i].position.y  = 200)  then

            begin
                apple[i].Position.y := 800;
                AppleCounter := AppleCounter + 1;
            end;
           
       vseOK := true;

        end;

        for n:= 0 to 6 do
        begin

            if (knife[n].position.y = 200) and 
            (knife[n].position.u  >= 260) and 
            (knife[n].position.u  <= 280) then
            begin
                
                vseOK := false;
                break;
                
            end;
        end;

            if (vseOK) then
            begin
                
                 knife[KnifeNumber].Position.y := 200;

                 knife[KnifeNumber].Position.u := 270;

                 KnifeNumber:= KnifeNumber + 1;

                 KnifeCounter := KnifeCounter + 2;
            end;         
        end;
    end;    
end;


procedure Round1();
var
    i: Integer;
   
begin   
    
    StartGraphics();


    KnifeNumber := 0;
 
    apple[0].Position.u := 10;
    apple[0].Position.y := 200;
   
    KnifeSpeed := 2;
    AppleSpeed := 2;


    for i:= 0 to 6 do
    begin
        knife[i].Position.u := 270;
        knife[i].Position.y := 430;
    end;
    
   
    //Вызов процедуры вывода на экран анимации ножей(задавать разное количество ножей, под разными изначальными углами)
    
    UpdateGraph(UpdateOff);

    while true do
    begin

    ClearDevice();

    DrawBackGround();

    SetColor(Red);
    OutTextXY(620,15,'You caught  '+ inttostr(AppleCounter) + ' apples');
    SetColor(white);
    OutTextXY(10,15,'Your score  '+ inttostr(KnifeCounter) );


        for i := 0 to 6 do
        begin
     
         //readkey();     


            DrawOneKnife(       
                round(knife[i].position.y),
                round(knife[i].position.u + 0)
                );
           

            if (knife[i].Position.y = 200) then
            begin

                knife[i].position.u := knife[i].position.u + knifeSpeed;

                if knife[i].position.u > 360 then 
                begin
                    knife[i].position.u := knife[i].position.u - 360;
                end;
            end;

            if apple[i].position.u > 360 then 
            begin
                apple[i].position.u := apple[i].position.u - 360;
            end;
        
       
        end;

        DrawApple(       
        round(apple[0].position.y),
        round(apple[0].position.u + 0)
        );

        apple[0].position.u := apple[0].position.u + appleSpeed ;


        DrawTree(400,200);

        updateGraph(UpdateNow);
        Delay(20); 

        UpdateGraph(UpdateOff);

        Keyboard();
    
        if (Isquit) then
        begin
            break;          
        end;

    end;


end;

procedure Round2();
var
    i: Integer;
   
begin   
    
    StartGraphics();


    KnifeNumber := 0;
 
    apple[0].Position.u := 10;
    apple[0].Position.y := 200;
   
    KnifeSpeed := 2;
    AppleSpeed := 2;


    for i:= 0 to 6 do
    begin
        knife[i].Position.u := 270;
        knife[i].Position.y := 430;
    end;
    
   
    //Вызов процедуры вывода на экран анимации ножей(задавать разное количество ножей, под разными изначальными углами)
    
    UpdateGraph(UpdateOff);

    while true do
    begin

    ClearDevice();

    DrawBackGround();

    SetColor(Red);
    OutTextXY(620,15,'You caught  '+ inttostr(AppleCounter) + ' apples');
    SetColor(white);
    OutTextXY(10,15,'Your score  '+ inttostr(KnifeCounter) );


        for i := 0 to 6 do
        begin
     
         //readkey();     


            DrawOneKnife(       
                round(knife[i].position.y),
                round(knife[i].position.u + 0)
                );
           

            if (knife[i].Position.y = 200) then
            begin

                knife[i].position.u := knife[i].position.u + knifeSpeed;

                if knife[i].position.u > 360 then 
                begin
                    knife[i].position.u := knife[i].position.u - 360;
                end;
            end;

            if apple[i].position.u > 360 then 
            begin
                apple[i].position.u := apple[i].position.u - 360;
            end;
        
       
        end;

        DrawApple(       
        round(apple[0].position.y),
        round(apple[0].position.u + 0)
        );

        apple[0].position.u := apple[0].position.u + appleSpeed ;


        DrawTree(400,200);

        updateGraph(UpdateNow);
        Delay(20); 

        UpdateGraph(UpdateOff);

        Keyboard();
    
        if (Isquit) then
        begin
            break;          
        end;

    end;


    ClearDevice();
    DrawBackGround();
    SetColor(Red);
    OutTextXY(400,300, 'GAME OVER'); //Dodelat' s kartinkoy
    UpdateGraph(UpdateNow);
    readkey();
end;

begin
    
 
    Round1();
    Round2();


    CloseGraph();
end.