program example;

uses
	//osxbgi;
	wingraph, wincrt, windows;

//
// TESTING app
//

const
	figureSpeed = 1.7;
	keySpeed = 0.7;

type
	TCoord = record
		x,y : real;		
	end;

	TFigureType = record
		pos : TCoord;
		speed : TCoord;		
	end;

var
	flyPoint, flyCircle, flyRect: TFigureType;

	myPoint, myCircle, myRect: TFigureType;

procedure StartGraphics();
var
	gd,gm: SmallInt;
begin
	gd := nopalette;
	gm := m800x600;
	InitGraph(gd,gm,'Hello World');	

	if (GraphResult <> grOK) then
	begin
		writeln('Cannot init graphics');
		halt;
	end;
end;

procedure Move(var figure: TFigureType);
begin
	figure.pos.y := figure.pos.y + figure.speed.y;

	if (figure.pos.y > 400) or (figure.pos.y < 100) then
	begin
		figure.speed.y := -figure.speed.y;
	end;
end;

procedure MoveAll();
begin
	move(flyPoint);
	move(flyCircle);
	move(flyRect);

	if (isKeyPressed(VK_Q)) then
		myPoint.pos.x := myPoint.pos.x - keySpeed;
	if (isKeyPressed(VK_E)) then
		myPoint.pos.x := myPoint.pos.x + keySpeed;

	if (isKeyPressed(VK_A)) then
		myRect.pos.x := myRect.pos.x - keySpeed;
	if (isKeyPressed(VK_D)) then
		myRect.pos.x := myRect.pos.x + keySpeed;

	if (isKeyPressed(VK_Z)) then
		myCircle.pos.x := myCircle.pos.x - keySpeed;
	if (isKeyPressed(VK_C)) then
		myCircle.pos.x := myCircle.pos.x + keySpeed;
end;

procedure DrawAll();
begin

	SetFillStyle(solidFill, yellow);
	SetColor(yellow);

	putPixel(round(flyPoint.pos.x), round(flyPoint.pos.y), yellow);	

	Bar(round(flyRect.pos.x - 10),
		round(flyRect.pos.y - 15),
		round(flyRect.pos.x + 10),
		round(flyRect.pos.y + 15)
		);
	putPixel(round(flyRect.pos.x), round(flyRect.pos.y), red);	

	FillEllipse(
		round(flyCircle.pos.x),
		round(flyCircle.pos.y),
		12,
		12
		);
	putPixel(round(flyCircle.pos.x), round(flyCircle.pos.y), red);	

	SetFillStyle(solidFill, green);
	SetColor(green);

	putPixel(round(myPoint.pos.x), round(myPoint.pos.y), WHITE);

	Bar(round(myRect.pos.x - 10),
		round(myRect.pos.y - 15),
		round(myRect.pos.x + 10),
		round(myRect.pos.y + 15)
		);

	FillEllipse(
		round(myCircle.pos.x),
		round(myCircle.pos.y),
		12,
		12
		);
end;

procedure MainLoop();
var
	Distance: real;
begin

	flyPoint.pos.x := 100;
	flyPoint.pos.y := 100;
	flyPoint.speed.x := 0;
	flyPoint.speed.y := figureSpeed;

	flyRect := flyPoint;
	flyRect.pos.x := 300;

	flyCircle := flyPoint;
	flyCircle.pos.x := 500;

	myRect.pos.x := 200;
	myRect.pos.y := 250;
	myRect.speed.x := 0;
	myRect.speed.y := 0;

	myPoint := myRect;
	myPoint.pos.y := 150;

	myCircle := myRect;
	myCircle.pos.y := 350;

	UpdateGraph(updateOff);

	while true do
	begin

		ClearDevice();

		DrawAll();

		MoveAll();
		
		SetColor(white);

		// Check collisions
		if (myPoint.pos.x >= flyRect.pos.x - 10) and
			(myPoint.pos.x <= flyRect.pos.x + 10) and
			(myPoint.pos.y >= flyRect.pos.y - 15) and
			(myPoint.pos.y <= flyRect.pos.y + 15) then
		begin
			OutTextXY(10, 10, 'collision PR');
		end;

		if (myPoint.pos.x = flyPoint.pos.x) and
			(myPoint.pos.Y = flyPoint.pos.Y) then
		begin
		 	OutTextXY(10, 10, 'collision PP');
		end;

		Distance := sqrt(
			sqr(myPoint.pos.x - flyCircle.pos.x) +
			sqr(mypoint.pos.y - flyCircle.pos.y)
			);
		IF Distance <= 12 then
		begin
		 	OutTextXY(10, 10, 'collision PC');
		end;

		Distance := sqrt(
			sqr(myCircle.pos.x - flyCircle.pos.x) +
			sqr(myCircle.pos.y - flyCircle.pos.y)
			);
		IF Distance <= (12 + 12) then
		begin
		 	OutTextXY(10, 30, 'collision CC');
		end;

		if
			((myRect.pos.x + 10) >= (flyRect.pos.x - 10)) and
			((myRect.pos.x - 10) <= (flyRect.pos.x + 10)) and
			((myRect.pos.y + 15) >= (flyRect.pos.y - 15)) and
			((myRect.pos.y - 15) <= (flyRect.pos.y + 15)) then
		begin
			OutTextXY(10, 50, 'collision RR');
		end;
		
		if (isKeyPressed(VK_ESCAPE)) then break;

		UpdateGraph(updateNow);

		delay(20);
	end;	
end;

//
// Main procedure
//
begin
	StartGraphics();

	MainLoop();


	CloseGraph();
end.
